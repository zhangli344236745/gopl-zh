### 2.3.1. 简短变量声明

在函数内部, 有一种称为简短变量声明的形式可用于声明和初始化局部变量. 以 `名字 := 表达式` 方式声明变量, 变量的类型根据表达式来推导. 这里函数中是三个简短变量声明语句(§1.4):

```Go
anim := gif.GIF{LoopCount: nframes}
freq := rand.Float64() * 3.0
t := 0.0
```

因为简洁和灵活性, 简短变量声明用于大部分的局部变量的声明和初始化. var 方式的声明往往是用于需要显示指定类型的局部变量, 或者因为稍后会被赋值而初始值无关紧要的变量.


```Go
i := 100  // an int
var boiling float64 = 100 // a float64
var names []string
var err error
var p Point
```

于 var 声明变量一样, 简短变量声明也可以用来声明和初始化一组变量:

```Go
i, j := 0, 1
```

但是这种声明多个变量的方式只简易在可以提高代码可读性的地方使用, 比如 for 循环的初始化部分.

请记住 `:=` 是一个变量声明, 而 `=` 是一个赋值操作. 不要混淆多个变量的声明和元组的多重(§2.4.1), 后者是将右边的表达式值赋给左边对应位置的变量:

```Go
i, j = j, i // 交换 i 和 j 的值
```

和普通 var 变量声明一样, 简短变量声明也可以用调用函数的返回值来声明, 像 os.Open 函数返回两个值:

```Go
f, err := os.Open(name)
if err != nil {
	return err
}
// ...use f...
f.Close()
```

这里有一个比较微妙的地方: 简短变量声明左边的全部变量可能并不是全部都是刚刚声明的. 如果有一些已经在相同的词法块声明过了(§2.7), 那么简短变量声明对这些已经声明过的变量就只有赋值行为了.

在下面的代码中, 第一个语句声明了 in 和 err 变量. 第二个语句只声明了 out, 然后对已经声明的 err 进行赋值.

```Go
in, err := os.Open(infile)
// ...
out, err := os.Create(outfile)
```

简短变量声明必须至少声明一个新的变量, 否则编译将不能通过:

```Go
f, err := os.Open(infile)
// ...
f, err := os.Create(outfile) // compile error: no new variables
```

解决的方法是第二个语句改用普通的赋值语言.

简短变量声明只有对在变量已经在同级词法域声明过的变量才和赋值操作等同, 如果变量是在外部词法域声明了, 那么将会声明一个新变量. 我们在本章后面将会看到类似的例子.


